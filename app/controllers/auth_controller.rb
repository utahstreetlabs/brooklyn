require 'ladon/resource/base'

# A controller that handles external network authentication callbacks using OmniAuth.
class AuthController < ApplicationController
  include Controllers::SignupFlow

  skip_requiring_login_only
  skip_store_login_redirect

  before_filter :set_network, only: :callback

  # Receives post-authentication callbacks from the external network.
  def callback
    auth = build_auth
    respond_to do |format|
      if logged_in?
        add_identity_to_current_user(auth)
        welcome_user(current_user)
        format.html { redirect_logged_in_user }
        format.json { render_jsend_success(:logged_in) }
      else
        user = find_or_create_user_from_auth(auth)
        if user
          user.remember_me! if session.delete(:remember_me)
          if user.connected?
            setup_new_user(user, auth)
            format.html { redirect_to_signup_flow_entry_point }
            format.json { render_jsend_success(:connected, new_profile_data(user, auth)) }
          elsif user.registered?
            setup_existing_user(user)
            format.html { redirect_after_onboarding_check(user, request.env['omniauth.origin']) }
            format.json { render_jsend_success(:registered) }
          else
            notify_visitor_user_creation_failed(user)
            format.html { redirect_after_auth(request.env['omniauth.origin'] || login_path) }
            format.json { render_jsend(error: :user_creation) }
          end
        else
          format.html { redirect_to(login_path) }
          format.json { render_jsend(error: :no_user) }
        end
      end
    end
  end

  # This method differs from +setup+ in that it is designed to be called explicitly to handle brooklyn-specific
  # parameters.  Then it will redirect to OAuth's rack middleware magic.
  def prepare
    remember_remember_me
    remember_signup_flow_type
    remember_signup_flow_origin_type
    remember_signup_flow_destination
    remember_signup_flow_network
    redirect_to auth_path(params[:network] || 'facebook')
  end

  # Gets called by omniauth before redirecting to the remote oauth site.  Allows us to capture any logging /
  # tracking details.
  # Returns a 404, which oddly signals omniauth to continue on with processing auth.
  # See https://github.com/intridea/omniauth/wiki/Dynamic-Providers
  def setup
    # this method gets called before *each* omniauth endpoint call, so try to avoid logging when we're returning from
    # oauth'ing
    unless stored_register_redirect
      reg_redirect = params[:r]
      reg_redirect ||= request.referer if params[:ot] && (params[:ot] == "far") # facebook auth referral
      store_register_redirect(reg_redirect)
    end

    unless stored_auth_redirect
      auth_redirect = params[:r]
      auth_redirect ||= root_path if params[:state] && (params[:state] == 'w')
      store_auth_redirect(auth_redirect)
    end

    remember_remember_me
    remember_signup_flow_scope
    remember_signup_flow_type
    remember_signup_flow_origin_type
    remember_signup_flow_destination
    remember_signup_flow_network
    render :text => "Setup complete.", :status => 404
  end

  # Receives failure callbacks generated by OmniAuth when exceptions are encountered communicating with the
  # external service. This seems to include cases where the user denies our connection request.
  def failure
    network = session.delete(:signup_flow_network)
    if params[:message] == 'invalid_credentials'
      scope = session.delete(:signup_flow_scope)
      lambda = network ? Network.klass(network).auth_failure_lambda(scope: scope) : nil
      if lambda && current_user
        lambda.call(current_user)
        set_flash_message(:notice, Network.klass(network).auth_failure_message(scope: scope))
      else
        # When we try to connect the user and fail because the connection was cancelled (ie. we're denied permission
        # by user), we show the signup modal on load with the alert inside the modal rather than float at top of page.
        session[:hide_global_flash] = session[:show_signup_alert] = true
        session[:force_auth] = :immediate
        set_flash_message(:alert, :cancelled)
      end
    else
      msg = "Network connection failure for user #{current_user ? current_user.person_id : 'unregistered user'}: #{params[:message]}"
      logger.error(msg)
      if e = request.env['omniauth.error']
        log_stack_trace(e)
      end
      set_flash_message(:alert, :error_communicating)
    end
    respond_to do |format|
      format.html { redirect_to session.delete(:signup_flow_destination) || request.env['omniauth.origin'] || root_path }
      format.json { render_jsend(error: :external_service_failed) }
    end
  end

protected

  def with_auth_error_handling(&block)
    rv = nil
    begin
      rv = block.call
    rescue ConnectionFailure
      set_flash_message(:alert, :error_connecting, network: @network.canonical_name)
    rescue ExistingConnectedProfile
      set_flash_message(:alert, :error_network_registered, network: @network.canonical_name)
    rescue InvalidCredentials
      set_flash_message(:alert, :error_connecting, network: @network.canonical_name)
    rescue Ladon::Resource::LadonResourceException
      set_flash_message(:alert, :error_communicating, network: @network.canonical_name)
    end
    rv
  end

  def remember_remember_me
    session[:remember_me] = (params[:remember_me] == "1")
  end

  def stash_gender(user, auth)
    if auth.respond_to?(:extra) && auth.extra.respond_to?(:raw_info) && auth.extra.raw_info.respond_to?(:gender)
      user.stash_gender(auth.extra.raw_info.gender)
    end
  end

  def set_network
    # execute this line outside the +||+ to ensure the value is deleted (in case of short-circuiting)
    sfn = session.delete(:signup_flow_network)
    network = params[:network] || sfn
    @network = Network.klass(network.to_sym) if network
  end

  def welcome_user(user, options = {})
    # If the welcome parameter is set, we should display the welcome message whether the user was previously
    # connected or if they were just logged in.
    if params[:state] && params[:state] == 'w'
      welcome_msg = options[:new] ? :welcome_new : :welcome_existing
      welcome_name = current_user.present?? current_user.firstname : user.firstname
      if welcome_name.present?
        set_flash_message(:notice, welcome_msg, name: welcome_name)
      end
    end
  end

  def build_auth
    auth = request.env['omniauth.auth']
    # Scope stores permissions used in this request; if available, store them away.
    auth.merge!('scope' => request.env['omniauth.strategy'].options.fetch('scope', ""))
    # Client-side auth for Facebook (via the js sdk) doesn't populate omniauth.strategy, so we optionally
    # pull it out of the stored signup_flow_scope, if available.
    auth['scope'] ||= session.delete(:signup_flow_scope)
    auth.merge!('secure' => true) if @network.secure?
    auth
  end

  # If signing up a buyer we autofollow users immediately, since many users complete registration but then skip the
  # buyer onboarding flow and get dumped into an empty feed.
  def follow_autofollow_users(user)
    if determine_signup_flow_type == :buyer
      Users::AutofollowJob.enqueue(user.id)
    end
  end

  def accept_invite(user)
    return if user.accepted_invite?
    # invite acceptance is not critical, so don't let an error cause the auth flow to fail
    self.class.with_error_handling("Accept invite for user #{user.id}", user_id: user.id) do
      # invite code comes from the session if the user came via an invite landing page
      if code = session.delete(:invite_id)
        return user.accept_invite!(code)
      end
      # or the user may have pending FB U2U invites. shouldn't happen for an existing user in production, but it's
      # useful in development to be able to test with existing users.
      user.accept_pending_facebook_u2u_invite!(ignore_state: Rails.env.development?)
    end
  end

  def add_identity_to_current_user(auth)
    with_auth_error_handling do
      current_user.add_identity_from_oauth(@network, auth)
      # If we updated the scope and it's not the default for this network, display
      # a notice to the user that their preferences were updated.
      msg = @network.default_scope?(auth['scope']) ? :connected : :preferences_updated
      # set flash even on xhr here because in the cases that we do this in an xhr we immediately reload the page
      set_flash_message(:notice, msg, network: @network.canonical_name, xhr: true)
    end
  end

  def find_or_create_user_from_auth(auth)
    with_auth_error_handling do
      User.find_or_create_from_oauth!(@network, auth, user: {visitor_id: visitor_identity})
    end
  end

  def setup_existing_user(user)
    track_usage(:network_authentication, user: user, network: @network.symbol, user_type: :existing)
    accept_invite(user)
    welcome_user(user)
    sign_in_and_absorb_guest(user)
  end

  def setup_new_user(user, auth)
    track_usage(:network_authentication, user: user, network: @network.symbol, user_type: :new)
    follow_autofollow_users(user)
    accept_invite(user)
    welcome_user(user, new: true)
    sign_in(user)
    stash_gender(user, auth)
  end

  def notify_visitor_user_creation_failed(user)
    logger.error("Unable to create user from #{@network.symbol} profile: #{user.errors.inspect}")
    set_flash_message(:alert, :error_network_registered, network: @network.canonical_name)
  end

  def redirect_logged_in_user
    redirect_after_auth(session.delete(:signup_flow_destination) || request.env['omniauth.origin'] || root_path)
  end

  def render_jsend_success(user_state, data = {})
    render_jsend(success: data.merge(user_state: user_state))
  end

  def new_profile_data(user, auth)
    profile_form = render_to_string(partial: '/shared/profile_form.html',
                                    locals: {user: user,
                                             path: signup_buyer_profile_path(secure: true)})
    {
      profileForm: profile_form,
      title: view_context.t('new_profile.modal.personalized_title', username: user.firstname),
      authType: auth.provider,
      authId: auth.uid
    }
  end
end
